abstract module VerifiableLucid {
    import opened LucidTypes
    import opened Arr
    import opened Helpers

    type Event(==) 

    type time = nat
    type port = nat

    class Program {

        const TRecirc : nat := 1 // How long it takes for a packet / event to recirculate.

        var recircQueue : seq<(time, Event)> // the recirculation input queue
        var emittedEvents : map<(port, time), Event> // A trace of events forwarded by the switch
                                                   // emittedEvents[(p, t)] is the event 
                                                   // forwarded out of port p at time t.
        var trace : map<time, Event>                // A trace of events handled by the switch.
        var handlingRecirc : bool                   // internal variable: is the switch handling 
                                                    // the first event from the recirc queue?
        var curTime : nat                           // the current time. 
        var curTimestamp : uint32
        var generatedEvent : Opt<Event>             // The recirculation event generated by
                                                    // a handler.


        constructor ()
            ensures recircQueue == []
            ensures curTime == 0
            ensures trace == map[]
            ensures handlingRecirc == false
            ensures emittedEvents == map[]
            ensures generatedEvent == None()
        {
            recircQueue := [];
            trace := map[];
            curTime := 0;
            handlingRecirc := false;
            emittedEvents := map[];
            generatedEvent := None();
        }        

        /*
         *
         * methods called in handler implementations
         *
         */

        /* forward event e to port p at the current time */
        method generate_port(p : nat, e : Event)
            modifies this`emittedEvents
            ensures emittedEvents == old(emittedEvents)[(p, curTime) := e]
        {
            emittedEvents := emittedEvents[(p, curTime) := e];
        }

        /* generate a recirculation event, which will be placed into the 
           recirculation queue on the next clockTick() */
        method generate(e : Event) 
            modifies this`generatedEvent
            requires this.generatedEvent == None()
            ensures  this.generatedEvent == Some(e)
            {
                generatedEvent := Some(e);
            }

        /* Record an event to the events handled trace. */
        method record(e : Event) 
            modifies this`trace
            ensures records(e)
        {
            trace := trace[curTime := e];
        }


        /*
         *
         * predicates used in handler pre / post conditions
         *
         */

        /* has the handler forwarded event e to port p at the current time? */
        twostate predicate emits(p : nat, e : Event)
            reads this`emittedEvents, this`curTime
        {
               (p, curTime) in emittedEvents 
            && emittedEvents[(p, curTime)] == e
            // && emittedEvents == old(emittedEvents)[(p, curTime) := e]
        }

        /* has the handler generated a recirculation event e? */
        twostate predicate generates(e : Event) 
            reads this`generatedEvent
        {
            generatedEvent == Some(e)
        }

        /* did the handler record processing of event e in the execution trace? */
        twostate predicate records(e : Event)
            reads this`trace
            reads this`curTime
        {
            trace == old(trace)[curTime := e]            
        }

        /* 
            readyToHandle(e) is used as a precondition to mean that the switch
            is in a state where e is legal to be processed at the current time. 
                1. No event has been processed yet during this clock cycle.
                2. If a recirculation event has been selected for processing, 
                   that event is the first event in the recirculation queue.
                3. No recirculation events have been generated this clock cycle.
        */
        predicate readyToHandle(e : Event) 
            reads this`recircQueue, this`handlingRecirc, this`trace, this`curTime, this`generatedEvent
        {
            canUseCurrentClock() &&
            (handlingRecirc ==> isNextRecircEvent(e)) &&
            generatedEvent == None()
        }


        /*
         *
         * methods called in a event sequence test case _outside_ of the program. 
         *
         */

        /* Get a pointer to the first event in the recirculation queue. 
           Requires that there is an event in the recirculation queue, 
           and the first event is legal to process at this time, i.e., 
           it has a time less than or equal to the current time. */
        method nextRecirc() returns (e : Event)
            modifies this`handlingRecirc
            requires |recircQueue| > 0
            requires recircQueue[0].0 <= curTime
            ensures (e == recircQueue[0].1)
            ensures handlingRecirc
        {
            handlingRecirc := true;
            return recircQueue[0].1;
        }       


        /* 1. Advance the system clock, 
           2. perform recirculation queue management: 
                1. if the handler that just executed was processing a recirculation event, 
                   pop that event off of the front of the recirculation queue. 
                2. if the handler that just executed generated an event, 
                   append that event to the end of the recirculation queue
                   with an arrival time of currentTime + switch recirculation time.
                3. reset handlingRecirc and the generated event buffer. */
        method clockTick()
            modifies this`curTime, this`handlingRecirc, this`generatedEvent, this`recircQueue
            requires handlingRecirc ==> |recircQueue| > 0
            ensures curTime == old(curTime) + 1
            ensures handlingRecirc == false
            ensures generatedEvent == None()
            ensures 
                match (old(handlingRecirc), old(generatedEvent)) {
                    // if we are not handling a recirc, append the generated event (if there is one)
                    case (false, Some(e)) => recircQueue == (old(recircQueue) + [(old(curTime) + TRecirc, e)])
                    case (false, None) => recircQueue == old(recircQueue)
                    // if we _are_ handling a recirc, we also pop that recirc off of the front.
                    case (true, Some(e)) => recircQueue == (old(recircQueue)[1..] + [(old(curTime) + TRecirc, e)])
                    case (true, None) => recircQueue == old(recircQueue)[1..]
                }
        {
            // update recirc queue and state, then tick clock.
            match (handlingRecirc, generatedEvent) {
                case (false, Some(e)) => {
                    recircQueue := recircQueue + [(curTime + TRecirc, e)];
                }
                case (false, None()) => {}
                case (true, Some(e)) => {
                    recircQueue := recircQueue[1..] + [(curTime + TRecirc, e)];
                }
                case (true, None) => {
                    recircQueue := recircQueue[1..];                    
                }
            }
            generatedEvent := None();
            handlingRecirc := false;
            curTime := curTime + 1;
        }

        predicate canUseCurrentClock()
            reads this`trace, this`curTime
        {
            (curTime !in trace)
        }

        predicate isNextRecircEvent(e : Event) 
            reads this`recircQueue, this`handlingRecirc, this`curTime
        {
            (|recircQueue| > 0) && (recircQueue[0].1 == e) && (recircQueue[0].0 <= curTime)
        }

        /*** Depreciated helpers  ***/ 

        // event arrived from recirc
        predicate recircArrival(e : Event) 
            reads this`recircQueue, this`handlingRecirc, this`trace, this`curTime, this`generatedEvent
            {
                generatedEvent == None() 
                && canUseCurrentClock() 
                && handlingRecirc
                && isNextRecircEvent(e)
            }

        // event arrived from non recirc
        predicate networkArrival(e : Event) 
            reads this`recircQueue, this`handlingRecirc, this`trace, this`curTime
            {
                canUseCurrentClock() 
                && !handlingRecirc
            }


    }


}

module LucidTypes {
    type uint8 = x : nat | 0 <= x < 256
    type uint16 = x : nat | 0 <= x < 65536
    type uint20 = x : nat | 0 <= x < 1048576
    type uint24 = x : nat | 0 <= x < 16777216
    type uint32 = x : nat | 0 <= x < 4294967296
    type uint48 = x : int | 0 <= x < 281474976710656

    const max8 : nat := 256
    const max16 : nat := 65536
    const max20 : nat := 1048576
    const max24 : nat := 16777216
    const max32 : nat := 4294967296
    const max48 : nat := 281474976710656

    function to_uint8(x : int) : uint8
        ensures to_uint8(x) == x % max8
    { x % max8 }

    function to_uint16(x : int) : uint16
        ensures to_uint16(x) == x % max16
    { x % max16 }

    function to_uint20(x : int) : uint20
        ensures to_uint20(x) == x % max20
    { x % max20 }

    function to_uint24(x : int) : uint24
        ensures to_uint24(x) == x % max24
    { x % max24 }

    function to_uint32(x : nat) : uint32
        ensures to_uint32(x) == x % max32
    { x % max32 }

    function zeros(len : uint32) : seq<uint32> {
        seq(len, (_ => 0))
    }

}

module Arr {
    import opened LucidTypes
    type  tout<t> = t

    type memcalc<!t> = (t, t) -> tout<t>

    class LArray<t> { // LArray stands for LucidArray
        var cells : seq<t>
        constructor (init_cells : seq<t>) 
        ensures fresh(this)
        ensures cells == init_cells
        {
            cells := init_cells;
        }
        constructor Create(n: nat, init: t)
        ensures fresh(this)
        ensures cells == seq(n, (_ => init))
        {
            cells := seq(n, (_ => init));
        }

        static method  Get<t> (s: LArray<t>, idx: nat, mget: memcalc, garg: t) 
                                                            returns (oldVal: t)
        requires 0 <= idx < |s.cells|
        ensures oldVal == mget(s.cells[idx], garg)
        {
            oldVal := mget (s.cells[idx], garg);
        }

        static method Set<t> (s: LArray<t>, idx:nat, mset: memcalc, sarg: t)      
        modifies s`cells                                   
        requires 0 <= idx < |s.cells|
        ensures |s.cells| == |old(s.cells)|
        // The following line says that newArray is the same as s, except that
        // newArray.cells[idx] is updated to be mset(s.cells[idx], sarg).
        ensures s.cells == old(s.cells)[idx := mset(old(s.cells[idx]), sarg)]
        {
            s.cells := s.cells[idx := mset(s.cells[idx], sarg)];
        }

        static method  Update<t> (s: LArray<t>, idx: nat, mget: memcalc, garg: t,
                                                    mset: memcalc, sarg: t)
                                        returns (oldVal: t)
        modifies s`cells                                   
        requires 0 <= idx < |s.cells|
        ensures oldVal == mget(old(s.cells)[idx], garg)
        ensures |s.cells| == |old(s.cells)|
        // The following line says that newArray is the same as s, except that
        // newArray.cells[idx] is updated to be mset(s.cells[idx], sarg).
        ensures s.cells == old(s.cells)[idx := mset(old(s.cells[idx]), sarg)]
        {
            oldVal := mget (s.cells[idx], garg);
            s.cells := s.cells[idx := mset(s.cells[idx], sarg)];
            // must be called so that s := newVal;
        }

        // onlyChanged is a helper predicate that says that all elements of the array are the same as before, except for the one at index i.
        static twostate predicate updated_cell(s : LArray<t>, i : nat, newVal : t)
            reads s`cells
        {
                0 <= i < |s.cells|
            &&  |s.cells| == |old(s.cells)| 
            &&  s.cells == old(s.cells)[i := newVal]
        }

    }
    // generic memcalc
    function  nocalc<t> (oldVal: t, newArg: t) : t {  oldVal  }
    function  swapcalc<t> (oldVal: t, newArg: t) : t {  newArg  }


    // Create a vector of m arrays, each length n
    // Can only be used in the constructor of the Lucid program, 
    // because it allocates global memory
    method CreateArrayVec<t>(n : nat, m : nat, init : t)
        returns (rv : seq<LArray<t>>)
        ensures |rv| == m        
        ensures forall j | 0 <= j < |rv| :: rv[j].cells == seq(n, (_ => init))
        ensures forall j | 0 <= j < |rv| :: fresh(rv[j])
        ensures fresh(rv)
        ensures forall j, k :: 0 <= j < |rv| && 0 <= k < |rv| && j != k ==> rv[j] != rv[k]

    {
        rv := [];
        for i := 0 to m
            invariant |rv| == i
            invariant (forall j | 0 <= j < |rv| :: rv[j].cells == seq(n, (_ => init)))
            invariant forall j | 0 <= j < |rv| :: fresh(rv[j])
            invariant forall j, k :: 0 <= j < |rv| && 0 <= k < |rv| && j != k ==> rv[j] != rv[k]

        {
            var next := new LArray.Create(n, init);
            rv := rv + [next];
        }
    }

}

module Helpers {
    import opened LucidTypes
    import opened Std.Arithmetic.Power

    datatype Opt<t> = 
    | None()
    | Some(v : t)

    // random nat between s and e, but really just s.
    method rand(s : nat, e : nat) returns (rv : nat)
        requires s < e
        ensures s <= rv < e
    {
        return s;
    }
    
    method whatPow(seed : uint32, n : nat) 

    {
        LemmaPowPositive(2, n);
        var p := Pow(2, n);
        assert p >= 1;
        var v := seed % p;        
    }


    // model of Lucid builtin to hash to a uint<n> -- n <= 32 because of switch HW limit
    function hashn(n : nat, seed : nat, key : seq<nat>) : nat
        requires 0 < n <= 32        
        ensures hashn(n, seed, key) < Pow(2, n)
    {
        LemmaPowPositive(2, n);
        hash_nat(seed, key) % Pow(2, n)
    }

    // Inner method for hash builtin
    function {:fuel 16} hash_nat(seed : nat, key : seq<nat>) : nat
    {
        if |key| == 0
            then seed
            else key[0] + hash_nat(seed, key[1..])
    }

}
